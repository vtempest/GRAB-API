{"version":3,"file":"grab-api.umd.js","sources":["../src/grab-api.js"],"sourcesContent":["/**\n * ### GRAB: General Request APIs from Browser\n * ![grabAPILogo](https://i.imgur.com/TE7jBZm.png)\n * \n * 1. **Data Retrieval**: Fetches data from server APIs using JSON parameters and returns JSON responses or error objects\n * 2. **Request/Response Format**: Standardized JSON communication for both input parameters and output data\n * 3. **Automatic Loading States**: Sets `isLoading` to `true` during data fetching operations and `false` upon completion\n * 4. **Mock Server Support**: Configure `window.grabMockServer` for development and testing environments\n * 5. **Concurrent Request Handling**: Cancels duplicate or overlapping requests automatically\n * 6. **Timeout Configuration**: Customizable request timeout settings\n * 7. **Rate Limiting**: Built-in rate limiting to prevent API abuse\n * 8. **Debug Logging**: Comprehensive logging system for request monitoring\n * 9. **Request History**: Stores all request and response data in global `grabLog` object\n * 10. **Pagination Support**: Built-in pagination handling for large datasets\n * 11. **Environment Configuration**: Configurable base URLs for development and production environments\n * 12. **Frontend Caching**: Intelligent caching system that prevents redundant API calls for repeat requests\n * 13. **Modular Design**: Single, flexible function that can be called from any part of your application.\n * 14. **Framework Agnostic**: No dependency on React hooks or component lifecycle - works with any JavaScript framework\n * 15. **Universal Usage**:  More flexible than TanStack Query - works outside component initialization, \n * 16. **Minimalist Single Function**: Less boilerplate and complexity than axios, SuperAgent, Got, Alova\n * \n * @param {string} path The path in the API after base url\n * @param {object} response Pre-initialized object to store the response in,\n *  isLoading and error are also set on this object.\n * @param {object} [options={}] Request params for GET or POST and more options\n * @param {string} [options.method] default=\"GET\" The HTTP method to use\n * @param {boolean} [options.cancelPrevious]  default=true Cancel previous requests to same path\n * @param {boolean} [options.cancelIfOngoing] default=false Cancel if a request to path is in progress\n * @param {boolean}[options.cache] default=false Whether to cache the request and from frontend cache\n * @param {boolean} [options.debug] default=false Whether to log the request and response\n * @param {number} [options.timeout] default=20 The timeout for the request in seconds\n * @param {number} [options.rateLimit] default=0 If set, how many seconds to wait between requests\n * @param {string} [options.paginateResult] default=null The key to paginate result data by\n * @param {string} [options.paginateKey] default=\"page\" The key to paginate the request by\n * @param {string} [options.baseURL] default='/api/' base url prefix, override with SERVER_API_URL env\n * @param {boolean} [options.setDefaults] default=false Pass this with options to set\n *  those options as defaults for all requests.\n * @param {any} *\n * @returns {Promise<Object>} The response from the server API\n * @author [vtempest (2025)](https://github.com/vtempest/grab-api)\n * @example \n  import { grab } from \"grab-api.js\";\n  let responseData = $state({}) as {\n      results: Array<{title:string}>,\n      isLoading: boolean,\n      error: string,\n  };\n   \n  await grab('search', responseData, {\n    query: \"search words\",\n    method: 'POST'\n  })\n  //in svelte component\n  {#if responseData.results}\n      {responseData.results}\n  {:else if responseData.isLoading}\n      ...\n  {:else if responseData.error}\n      {responseData.error}\n  {/if}\n\n  //Setup Mock testing server, response is object or function\n  window.grabMockServer[\"search\"] = {\n    response: (params) => {\n      return { results: [{title:`Result about ${params.query}`}] };\n    },\n    method: \"POST\",\n    params: {\n      query: \"search words\"\n    },\n    delay : 1,\n  };\n\n  //set defaults for all requests\n  grab(\"\", {}, { \n    setDefaults: true,\n    baseURL: \"http://localhost:8080\",\n    timeout: 30,\n    debug: true,\n    rateLimit: 1,\n    cache: true,\n    cancelPrevious: true,\n    cancelIfOngoing: true,\n  });\n */\nexport async function grab(path, response = {}, options = {}) {\n  try {\n    // Destructure options with defaults, merging with any globally set defaults\n    let {\n      headers,\n      method = \"GET\",\n      cache = false, // Enable/disable frontend caching\n      timeout = 20, // Request timeout in seconds\n      baseURL = (typeof process !== \"undefined\" &&\n        process?.env?.SERVER_API_URL) ||\n        \"/api/\", // Use env var or default to /api/\n      cancelPrevious = true, // Cancel previous request for same path\n      cancelIfOngoing = false, // Don't make new request if one is ongoing\n      rateLimit = 0, // Minimum seconds between requests\n      debug = window?.location?.hostname?.includes(\"localhost\"), // Auto-enable debug on localhost\n      paginateResult = null, // Key to paginate in response\n      paginateKey = \"page\", // Request param for pagination\n      setDefaults = false, // Set these options as defaults for future requests\n      retryOnError = false, // Retry failed requests once\n      ...body // All other params become request body/query\n    } = { ...window.grabDefaults, ...options };\n\n    // Store options as defaults if setDefaults flag is true\n    if (options?.setDefaults) {\n      window.grabDefaults = { ...options, setDefaults: undefined };\n      return {};\n    }\n\n    // Initialize response object if not provided\n    if (!response) response = {};\n\n    // Initialize tracking for this request path\n    let logEntry = grabLog;\n    if (!(path in grabLog)) {\n      grabLog[path] = {\n        requestData: body || {},\n      };\n    }\n\n    // Check if this is a repeat request by comparing params\n    if (grabLog[path].requestData)\n      grabLog[path].requestData[paginateKey] = undefined;\n    const isRepeatRequest =\n      JSON.stringify(grabLog[path].requestData) == JSON.stringify(body);\n\n    // Handle response clearing/caching based on pagination\n    if (!paginateKey) {\n      // Return cached response if enabled and request is identical\n      if (cache && isRepeatRequest) {\n        for (let key of Object.keys(grabLog[path].responseData))\n          response[key] = grabLog[path].responseData[key];\n        return response;\n      }\n\n      // Clear previous response data\n      for (let key of Object.keys(response)) response[key] = undefined;\n    } else {\n      // Handle pagination - track current page and append results\n      var pageNumber = grabLog[path].currentPage || body?.[paginateKey] || 0;\n\n      if (!isRepeatRequest) {\n        response[paginateResult] = [];\n        pageNumber = 0;\n      }\n      grabLog[path].currentPage = ++pageNumber;\n      body[paginateKey] = pageNumber;\n    }\n\n    // Set loading state\n    response.isLoading = true;\n\n    // Enforce rate limiting if enabled\n    if (\n      rateLimit > 0 &&\n      grabLog[path]?.lastFetchTime &&\n      grabLog[path]?.lastFetchTime > Date.now() - 1000 * rateLimit\n    )\n      throw new Error(\"Fetch rate limit exceeded\");\n\n    // Handle request cancellation logic\n    if (grabLog[path]?.controller && isRepeatRequest)\n      if (cancelPrevious) grabLog[path].controller.abort();\n      else if (cancelIfOngoing) return { isLoading: true };\n\n    // Setup new request tracking\n    grabLog[path].lastFetchTime = Date.now();\n    grabLog[path].controller = new AbortController();\n\n    // Configure fetch parameters\n    const fetchParams = {\n      method,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        ...headers,\n      },\n      body: null,\n      redirect: \"follow\",\n      cache: cache ? \"force-cache\" : \"no-store\",\n      signal: cancelPrevious\n        ? grabLog[path]?.controller?.signal\n        : AbortSignal.timeout(timeout * 1000),\n    };\n\n    // Format request body/query params based on method\n    let paramsGETRequest = \"\";\n    if ([\"POST\", \"PUT\", \"PATCH\"].includes(method))\n      fetchParams.body = JSON.stringify(body);\n    else paramsGETRequest = \"?\" + new URLSearchParams(body).toString();\n\n    // Handle mock server responses if configured\n    let responseData = null,\n      startTime = new Date(),\n      mockHandler = grabMockServer?.[path];\n\n    if (\n      mockHandler &&\n      mockHandler.method == method &&\n      (!mockHandler.params ||\n        JSON.stringify(body) == JSON.stringify(mockHandler.params))\n    ) {\n      if (mockHandler.delay > 0)\n        await new Promise((resolve) => setTimeout(resolve, mockHandler.delay));\n\n      responseData = mockHandler.response;\n      if (typeof responseData === \"function\") responseData = responseData(body);\n    } else {\n      // Make actual API request if no mock\n      responseData = await fetch(baseURL + path + paramsGETRequest, fetchParams)\n        .catch((e) => {\n          throw new Error(e);\n        })\n        .then((res) => res.text());\n\n        // Parse response based on content type\n        if (responseData.startsWith(\"{\")) responseData = JSON.parse(responseData);\n        else if (responseData.includes(\"error\")) throw new Error(responseData);\n        else return responseData;\n      }\n\n\n    // Clear loading state\n    if (response) response.isLoading = undefined;\n\n    // Log debug information if enabled\n    if (debug) {\n      log(\n        \"Path:\" +\n          baseURL +\n          path +\n          paramsGETRequest +\n          \"\\n\" +\n          JSON.stringify(options, null, 2) +\n          \"\\nTime: \" +\n          ((Number(new Date()) - Number(startTime)) / 1000).toFixed(1) +\n          \"s\\nResponse: \" +\n          printStructureJSON(responseData)\n      );\n      // allows user to expand and collapse the object in console\n      console.log(responseData);\n    }\n\n    // Update response object with results, handling pagination\n    for (let key of Object.keys(responseData))\n      response[key] =\n        paginateResult == key && response[key]?.length\n          ? [...response[key], ...responseData[key]]\n          : responseData[key];\n\n    // Store request/response data for future reference\n    grabLog[path].controller = undefined;\n    grabLog[path].responseData = response;\n    grabLog[path].requestData = body || {};\n\n    return response;\n  } catch (error) {\n    // Handle errors, with optional retry\n    if (options.retryOnError)\n      return await grab(path, response, { ...options, retryOnError: false });\n\n    if (response) {\n      if (!error.message.includes(\"signal\")) response.error = error.message;\n      response.isLoading = false;\n    }\n    if (path in grabLog) grabLog[path].error = error.message;\n    return { error: error.message};\n  }\n}\n\n/**\n * Logs messages to the console with custom styling,\n * showing debug output in development and standard logs in production.\n * Pretty print JSON with description of structure layout.\n * @param {string|object} message - The message to log. If an object is provided, it will be stringified.\n * @param {boolean} [hideInProduction] -  default = auto-detects based on hostname.\n *  If true, uses `console.debug` (hidden in production). If false, uses `console.log`.\n * @param {string} [style] default=\"color: blue; font-size: 15px;\"] - CSS style string for the console output.\n */\nexport function log(\n  message,\n  hideInProduction = undefined,\n  style = \"color: blue; font-size: 14px;\"\n) {\n  if (typeof hideInProduction === \"undefined\")\n    hideInProduction = window?.location.hostname.includes(\"localhost\");\n  // pretty print JSON with description of structure layout\n  if (typeof message === \"object\")\n    message =\n      printStructureJSON(message) + \"\\n\\n\" + JSON.stringify(message, null, 2);\n\n  if (hideInProduction) console.debug((style ? \"%c\" : \"\") + message, style);\n  else console.log((style ? \"%c\" : \"\") + message, style);\n}\n\n/**\n * Generates TypeDoc-like string of layout of nested JSON object.\n * @param {Object} obj - The JSON object to describe.\n * @returns {string} A string of the object's structure.\n * @example { name: string, age: number, pets: Array<string>}\n */\nexport function printStructureJSON(obj) {\n  function getType(value) {\n    if (Array.isArray(value)) {\n      if (value.length === 0) return \"Array<unknown>\";\n      return `Array<${getType(value[0])}>`;\n    } else if (value === null) {\n      return \"null\";\n    } else if (typeof value === \"object\") {\n      return printStructureJSON(value);\n    } else {\n      return typeof value;\n    }\n  }\n\n  if (typeof obj !== \"object\" || obj === null) {\n    return getType(obj);\n  }\n\n  let result = \"{ \";\n  const keys = Object.keys(obj);\n  keys.forEach((key, index) => {\n    result += `${key}: ${getType(obj[key])}`;\n    if (index < keys.length - 1) {\n      result += \", \";\n    }\n  });\n  result += \" }\";\n  return result;\n}\n\nconst grabLog = [];\nconst grabMockServer = {};\nconst grabDefaults = {};\n\n// Add globals to window in browser, or global in Node.js\nif (typeof window !== \"undefined\") {\n  window.grabLog = grabLog;\n  window.grabMockServer = grabMockServer;\n  window.grabDefaults = grabDefaults;\n} else if (typeof global !== \"undefined\") {\n  global.grabLog = grabLog;\n  global.grabMockServer = grabMockServer;\n  global.grabDefaults = grabDefaults;\n}\n\n"],"names":["log","message","hideInProduction","style","window","location","hostname","includes","printStructureJSON","JSON","stringify","console","debug","obj","getType","value","Array","isArray","length","result","keys","Object","forEach","key","index","grabLog","grabMockServer","grabDefaults","global","async","grab","path","response","options","headers","method","cache","timeout","baseURL","process","_a","env","SERVER_API_URL","cancelPrevious","cancelIfOngoing","rateLimit","_c","_b","paginateResult","paginateKey","setDefaults","retryOnError","body","requestData","isRepeatRequest","pageNumber","currentPage","responseData","isLoading","_d","lastFetchTime","_e","Date","now","Error","_f","controller","abort","AbortController","fetchParams","Accept","redirect","signal","_h","_g","AbortSignal","paramsGETRequest","URLSearchParams","toString","startTime","mockHandler","params","fetch","catch","e","then","res","text","startsWith","parse","delay","Promise","resolve","setTimeout","Number","toFixed","_i","error"],"mappings":"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"}